#include <string>
#include <vector>
#include <iostream>

#include "Vertex.h"
#include "Edge.h"
#include "Graph.h"
#include "BFS.h"
#include "SCCGraph.h"


#include "catch.hpp"

Graph basicTestGraph() {
	Graph g = Graph();
	Vertex v0 = Vertex(0, "zero");
    Vertex v1 = Vertex(1, "one");
    Vertex v2 = Vertex(2, "two");
    Vertex v3 = Vertex(3, "three");

    g.insertVertex(v0);
    g.insertVertex(v1);
    g.insertVertex(v2);
    g.insertVertex(v3);
    
    g.insertEdge(v0, v1);
    g.insertEdge(v1, v2);
    g.insertEdge(v2, v3);
    g.insertEdge(v3, v0);

	return g;
}

TEST_CASE("Verify that these tests compile") {
	REQUIRE(true);
}

TEST_CASE("Verify that vertices and edges are properly inserted", "[GraphADT]") {
	Graph g = basicTestGraph();

	REQUIRE(g.num_vertices == 4);
	REQUIRE(g.num_edges == 4);
}

TEST_CASE("Verify that edgeExists queries work","[GraphADT]") {
	Vertex v0 = Vertex(0, "zero");
    Vertex v1 = Vertex(1, "one");
    Vertex v2 = Vertex(2, "two");
    Vertex v3 = Vertex(3, "three");
    Graph g = basicTestGraph();

	REQUIRE(g.edgeExists(v0, v1) == true);
	REQUIRE(g.edgeExists(v1, v1) == false);
	REQUIRE(g.edgeExists(v2, v3) == true);
}

TEST_CASE("Verify that vertexExists queries work", "[GraphADT]") {
	Vertex v0 = Vertex(0, "zero");
    Vertex v1 = Vertex(1, "one");
    Vertex v2 = Vertex(25, "anything");
    Graph g = basicTestGraph();

	REQUIRE(g.vertexExists(v0) == true);
	REQUIRE(g.vertexExists(v1) == true);
	REQUIRE(g.vertexExists(v2) == false);
}

TEST_CASE("Demonstrate how to use the incidentEdges and incidentVertices function.", "[GraphADT]") {
    Graph g = basicTestGraph();
	Vertex v0 = Vertex(0, "zero");
	for (auto& it : g.incidentEdges(v0)) {
        Edge incidentEdge = it; 
	}
    for(auto& it : g.incidentVertices(v0)){
        Vertex incidentVertex = it;
    }
	REQUIRE(true);
}

TEST_CASE("Verify that removeEdge function work as expected.", "[GraphADT]"){
    Graph g = basicTestGraph();
    Vertex v0(0, "zero");
    Vertex v1(1, "one");

    g.removeEdge(v0, v1);

    REQUIRE(g.num_edges == 3);
    REQUIRE(g.edgeExists(v0, v1) == false);

    g.removeEdge(v0, v1);       // this should not remove anything
    REQUIRE(g.num_edges == 3);  // num_edges should remain same for non-existent edge
}

TEST_CASE("Verify that removeVertex function work as expected.", "[GraphADT]"){
    Graph g = basicTestGraph();
    Vertex v0(0, "zero");

    g.removeVertex(v0);

    REQUIRE(g.num_vertices == 3);           // function should remove the Vertex
    REQUIRE(g.vertexExists(v0) == false);
    REQUIRE(g.num_edges == 2);              // function should remove all the vertex's Edges
}

TEST_CASE("Verify the BFS works as expected", "[BFS]") {
    Graph g = basicTestGraph();
    Vertex v0(0, "zero");
    BFSTraversal bfs = g.getBFS(v0);
    
    int count = 0;
    for (auto b : bfs) {
        CAPTURE(b);
        count++;
    }
    REQUIRE(count == 4);
}

TEST_CASE("Show that in a BFS, we know where we came from.", "[BFS]") {
    Graph g = basicTestGraph();
    Vertex v0(0, "zero");
    BFSTraversal bfs = g.getBFS(v0);
    int count{};
    for (auto b : bfs) {
        CAPTURE(b);
        count++;
    }
    REQUIRE(count == 4);
}

TEST_CASE("Loading the first part of the wiki dataset works") {
    Graph gIO = Graph("./tests/mock-data/Vertices.csv", "./tests/mock-data/Edges.txt");
    CHECK(gIO.num_vertices < 20);
}

TEST_CASE("Loading data automatically generated by the python script works") {
    Graph gIO = Graph("./tests/mock-data/pre-gen-names.csv", "./tests/mock-data/pre-gen-edges.txt");
    CHECK(gIO.num_vertices == 10);
    CHECK(gIO.num_edges == 30);
}

TEST_CASE("Because SCCGraphs are Graphs, a SCCGraph is traversable and correctly produces the acyclic graph") {
    SCCGraph sIO("./tests/mock-data/scc-examples/scc-names-hand.csv", "./tests/mock-data/scc-examples/scc-edges-hand.txt");
    BFSTraversal bfs = sIO.getBFS(0);
    int count{};
    for (auto it = bfs.begin(); it != bfs.end(); ++it) {
        std::cout << *it << ", ";
        count++;
    }
    REQUIRE(count == 5);
}